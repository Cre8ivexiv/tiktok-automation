<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Quick Clips Web UI</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #111a33;
      --border: #2a3a6a;
      --text: #ecf2ff;
      --muted: #b8c5ea;
      --ok: #26d07c;
      --warn: #f7b955;
      --bad: #f26c7a;
      --accent: #5bc7ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Segoe UI, Tahoma, sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 20% 15%, #1a2d58 0%, transparent 35%), var(--bg);
      min-height: 100vh;
      padding: 20px;
    }
    .wrap {
      max-width: 1400px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 470px 1fr;
      gap: 16px;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
    }
    h1, h2 {
      margin: 0 0 10px;
      line-height: 1.2;
    }
    h1 { font-size: 22px; }
    h2 { font-size: 16px; color: var(--muted); }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .field {
      margin-bottom: 8px;
    }
    .field label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .field input, .field select {
      width: 100%;
      padding: 9px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #0d1630;
      color: var(--text);
    }
    .btn-row {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }
    button {
      border: 1px solid #2d4a84;
      border-radius: 8px;
      background: #12306a;
      color: #eef4ff;
      padding: 9px 12px;
      cursor: pointer;
      font-weight: 600;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .status {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      background: #1e315f;
      margin-bottom: 8px;
      font-size: 12px;
    }
    .status.ok { background: rgba(38, 208, 124, 0.2); color: #91f0be; }
    .status.warn { background: rgba(247, 185, 85, 0.2); color: #ffd792; }
    .status.bad { background: rgba(242, 108, 122, 0.2); color: #ffb0b9; }
    .log, .parts, .ffmpeg {
      background: #090f22;
      border: 1px solid #23345f;
      border-radius: 10px;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      overflow: auto;
    }
    .log { min-height: 280px; max-height: 460px; }
    .parts, .ffmpeg { min-height: 80px; max-height: 220px; margin-top: 8px; }
    .small {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }
    @media (max-width: 1100px) {
      .wrap { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="card">
      <h1>Quick Clips Processor</h1>
      <h2>API-connected UI</h2>

      <div class="field">
        <label for="url">URL or local path</label>
        <input id="url" placeholder="https://... or C:\path\video.mp4">
      </div>
      <div class="field">
        <label for="title">Title</label>
        <input id="title" placeholder="Solo Leveling Recap">
      </div>
      <div class="field">
        <label for="channel">Channel</label>
        <select id="channel"></select>
      </div>

      <div class="row">
        <div class="field">
          <label for="partSeconds">Part seconds</label>
          <input id="partSeconds" type="number" value="70" min="1">
        </div>
        <div class="field">
          <label for="intervalMin">Interval minutes</label>
          <input id="intervalMin" type="number" value="30" min="1">
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="cropTopPx">Crop top px</label>
          <input id="cropTopPx" type="number" value="0" min="0">
        </div>
        <div class="field">
          <label for="titleMaskPx">Title mask px</label>
          <input id="titleMaskPx" type="number" value="0" min="0">
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="edgeBarPx">Edge Bar PX (overlay only)</label>
          <input id="edgeBarPx" type="number" value="45" min="0" max="200">
        </div>
      <div class="field">
        <label for="contentHeightBumpPx">Content Height Bump PX (zoom mode)</label>
        <input id="contentHeightBumpPx" type="number" value="0" min="0" max="1600">
      </div>

      <div class="field">
        <label for="contentMaxHeightPx">Content Max Height PX (zoom mode stop line)</label>
        <input id="contentMaxHeightPx" type="number" value="0" min="0" max="1920">
      </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="yScaleMode">Y scale mode</label>
          <select id="yScaleMode">
            <option value="letterbox" selected>letterbox</option>
            <option value="zoom">zoom</option>
            <option value="manual">manual</option>
            <option value="fill">fill</option>
          </select>
        </div>
        <div class="field">
          <label for="videoYScale">Video Y scale (manual/fill)</label>
          <input id="videoYScale" type="number" step="0.01" value="2.08" min="0.01">
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="outputWidth">Output width</label>
          <input id="outputWidth" type="number" value="1080" min="2">
        </div>
        <div class="field">
          <label for="outputHeight">Output height</label>
          <input id="outputHeight" type="number" value="1920" min="2">
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="partLabelPosition">Part label position</label>
          <select id="partLabelPosition">
            <option value="top-center" selected>top-center</option>
            <option value="top-left">top-left</option>
          </select>
        </div>
        <div class="field">
          <label for="renderPreset">Render preset</label>
          <input id="renderPreset" value="legacy">
        </div>
      </div>

      <div class="field">
        <label><input id="noPartOverlay" type="checkbox"> Disable Part overlay</label>
      </div>

      <div class="btn-row">
        <button id="processBtn">Process</button>
        <button id="stopBtn" disabled>Stop Poll</button>
      </div>
      <div class="small">Uses relative API URLs only. No hardcoded host/port.</div>
    </section>

    <section class="card">
      <div id="status" class="status">Idle</div>
      <div id="meta" class="small"></div>
      <div class="log" id="log"></div>
      <div class="parts" id="parts"></div>
      <div class="ffmpeg" id="ffmpeg"></div>
    </section>
  </div>

  <script>
    const ui = {
      url: document.getElementById("url"),
      title: document.getElementById("title"),
      channel: document.getElementById("channel"),
      partSeconds: document.getElementById("partSeconds"),
      intervalMin: document.getElementById("intervalMin"),
      cropTopPx: document.getElementById("cropTopPx"),
      titleMaskPx: document.getElementById("titleMaskPx"),
      edgeBarPx: document.getElementById("edgeBarPx"),
      contentHeightBumpPx: document.getElementById("contentHeightBumpPx"),
      contentMaxHeightPx: document.getElementById("contentMaxHeightPx"),
      yScaleMode: document.getElementById("yScaleMode"),
      videoYScale: document.getElementById("videoYScale"),
      outputWidth: document.getElementById("outputWidth"),
      outputHeight: document.getElementById("outputHeight"),
      partLabelPosition: document.getElementById("partLabelPosition"),
      renderPreset: document.getElementById("renderPreset"),
      noPartOverlay: document.getElementById("noPartOverlay"),
      processBtn: document.getElementById("processBtn"),
      stopBtn: document.getElementById("stopBtn"),
      status: document.getElementById("status"),
      meta: document.getElementById("meta"),
      log: document.getElementById("log"),
      parts: document.getElementById("parts"),
      ffmpeg: document.getElementById("ffmpeg"),
    };

    const state = {
      jobId: null,
      polling: false,
      timer: null,
      failures: 0,
      consecutive404: 0,
      maxFailures: 5,
      max404Retries: 8,
      lastLogSignature: "",
    };

    function now() {
      return new Date().toLocaleTimeString();
    }

    function setStatus(text, kind = "neutral") {
      ui.status.textContent = text;
      ui.status.className = "status";
      if (kind === "ok") ui.status.classList.add("ok");
      if (kind === "warn") ui.status.classList.add("warn");
      if (kind === "bad") ui.status.classList.add("bad");
    }

    function appendLog(line) {
      const formatted = `[${now()}] ${line}`;
      ui.log.textContent += (ui.log.textContent ? "\n" : "") + formatted;
      ui.log.scrollTop = ui.log.scrollHeight;
    }

    function setLogsFromServer(lines) {
      if (!Array.isArray(lines)) return;
      const signature = JSON.stringify(lines);
      if (signature === state.lastLogSignature) return;
      state.lastLogSignature = signature;
      ui.log.textContent = lines.join("\n");
      ui.log.scrollTop = ui.log.scrollHeight;
      const ffmpegLines = lines.filter((l) => l.includes("FFmpeg cmd"));
      ui.ffmpeg.textContent = ffmpegLines.length ? ffmpegLines.join("\n") : "No FFmpeg cmd lines yet.";
    }

    function setParts(files) {
      if (!Array.isArray(files) || files.length === 0) {
        ui.parts.textContent = "No part files yet.";
        return;
      }
      ui.parts.textContent = files.join("\n");
    }

    async function fetchJson(path, options = {}) {
      const response = await fetch(path, options);
      const text = await response.text();
      let data = null;
      if (text) {
        try { data = JSON.parse(text); } catch (_) { data = null; }
      }
      if (!response.ok) {
        const detail = data && data.detail ? data.detail : text || `HTTP ${response.status}`;
        throw new Error(`${response.status} ${response.statusText}: ${detail}`);
      }
      return data ?? {};
    }

    function stopPolling(reason = "") {
      state.polling = false;
      if (state.timer) {
        clearTimeout(state.timer);
        state.timer = null;
      }
      ui.stopBtn.disabled = true;
      if (reason) appendLog(reason);
    }

    function nextDelay() {
      return Math.min(1000 * Math.pow(2, Math.max(0, state.failures - 1)), 10000);
    }

    async function pollOnce() {
      if (!state.polling || !state.jobId) return;
      try {
        const payload = await fetchJson(`/api/status/${encodeURIComponent(state.jobId)}`);
        state.failures = 0;
        state.consecutive404 = 0;

        setLogsFromServer(payload.logs || []);
        const statusPayload = payload.status || {};
        setParts(payload.part_files || statusPayload.part_files || []);
        ui.meta.textContent = `job_id=${payload.job_id || state.jobId} state=${payload.state || "unknown"}`;

        const currentState = payload.state || "unknown";
        if (currentState === "processed" || currentState === "uploaded") {
          setStatus(currentState, "ok");
          stopPolling("Polling stopped: terminal success state reached.");
          return;
        }
        if (currentState === "failed" || currentState === "upload_failed") {
          const err = payload.error || (statusPayload && statusPayload.error) || "Unknown error";
          setStatus(currentState, "bad");
          stopPolling(`Polling stopped: terminal failure state (${err}).`);
          return;
        }
        if (currentState === "queued" || currentState === "processing" || currentState === "uploading") {
          setStatus(currentState, "warn");
        } else {
          setStatus(currentState);
        }
      } catch (error) {
        state.failures += 1;
        const message = String(error && error.message ? error.message : error);
        if (message.startsWith("404")) {
          state.consecutive404 += 1;
          appendLog(`Status not ready yet (${state.consecutive404}/${state.max404Retries}): ${message}`);
          if (state.consecutive404 >= state.max404Retries) {
            setStatus("poll stopped", "bad");
            stopPolling(`Stopped polling after ${state.consecutive404} consecutive 404 responses.`);
            return;
          }
        } else {
          appendLog(`Status poll error (${state.failures}/${state.maxFailures}): ${message}`);
          if (state.failures >= state.maxFailures) {
            setStatus("poll stopped", "bad");
            stopPolling(`Stopped polling after ${state.failures} consecutive poll failures.`);
            return;
          }
        }
      }
      state.timer = setTimeout(pollOnce, nextDelay());
    }

    function startPolling(jobId) {
      stopPolling();
      state.jobId = jobId;
      state.polling = true;
      state.failures = 0;
      state.consecutive404 = 0;
      ui.stopBtn.disabled = false;
      state.timer = setTimeout(pollOnce, 800);
    }

    function requestPayload() {
      return {
        url: ui.url.value.trim(),
        title: ui.title.value.trim(),
        channel: ui.channel.value,
        crop_top_px: Number(ui.cropTopPx.value || 0),
        title_mask_px: Number(ui.titleMaskPx.value || 0),
        edge_bar_px: Number(ui.edgeBarPx.value || 45),
        content_height_bump_px: Number(ui.contentHeightBumpPx.value || 0),
        content_max_height_px: Number(ui.contentMaxHeightPx.value || 0),
        video_y_scale: Number(ui.videoYScale.value || 2.08),
        y_scale_mode: ui.yScaleMode.value || "letterbox",
        interval_min: Number(ui.intervalMin.value || 30),
        part_seconds: Number(ui.partSeconds.value || 70),
        output_width: Number(ui.outputWidth.value || 1080),
        output_height: Number(ui.outputHeight.value || 1920),
        render_preset: ui.renderPreset.value || "legacy",
        part_label_position: ui.partLabelPosition.value || "top-center",
        no_part_overlay: !!ui.noPartOverlay.checked,
      };
    }

    async function loadChannels() {
      try {
        const payload = await fetchJson("/api/channels");
        const channels = Array.isArray(payload.channels) ? payload.channels : [];
        if (!channels.length) {
          ui.channel.innerHTML = "<option value='anime recaps'>anime recaps</option>";
          return;
        }
        ui.channel.innerHTML = channels
          .map((name) => `<option value="${name.replace(/"/g, "&quot;")}">${name}</option>`)
          .join("");
      } catch (error) {
        appendLog(`Failed to load channels: ${error.message || error}`);
      }
    }

    async function startProcess() {
      const payload = requestPayload();
      if (!payload.url || !payload.title || !payload.channel) {
        setStatus("missing required fields", "bad");
        appendLog("URL, Title, and Channel are required.");
        return;
      }
      ui.processBtn.disabled = true;
      setStatus("submitting", "warn");
      appendLog("Submitting /api/process...");
      try {
        const data = await fetchJson("/api/process", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const jobId = data.job_id;
        if (!jobId) {
          throw new Error("No job_id returned from /api/process.");
        }
        appendLog(`Job created: ${jobId}`);
        setStatus("queued", "warn");
        startPolling(jobId);
      } catch (error) {
        setStatus("request failed", "bad");
        appendLog(`Process request failed: ${error.message || error}`);
      } finally {
        ui.processBtn.disabled = false;
      }
    }

    ui.processBtn.addEventListener("click", startProcess);
    ui.stopBtn.addEventListener("click", () => stopPolling("Polling stopped manually."));

    ui.log.textContent = "Ready.";
    ui.parts.textContent = "No part files yet.";
    ui.ffmpeg.textContent = "No FFmpeg cmd lines yet.";
    loadChannels();
  </script>
</body>
</html>
