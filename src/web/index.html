<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TikTok Scheduler Uploader</title>
  <style>
    :root {
      --bg: #070b15;
      --panel: #11192e;
      --panel-2: #0f1530;
      --line: #2b3b6b;
      --text: #f2f6ff;
      --muted: #b6c2e2;
      --accent: #59c7ff;
      --accent-2: #71ffb4;
      --danger: #ff6d9b;
      --ok: #45f0a1;
      --glow: 0 0 30px rgba(89, 199, 255, 0.35);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Segoe UI", "Inter", system-ui, -apple-system, sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 10% 10%, rgba(113, 255, 180, 0.12), transparent 34%),
        radial-gradient(circle at 90% 15%, rgba(89, 199, 255, 0.18), transparent 33%),
        linear-gradient(140deg, #050914 0%, #0a0f22 50%, #0d1430 100%);
      min-height: 100vh;
      padding: 28px;
    }

    .title-wrap {
      margin-bottom: 20px;
    }

    .app-title {
      margin: 0;
      font-size: clamp(24px, 4vw, 42px);
      letter-spacing: 0.4px;
      text-shadow: 0 0 24px rgba(89, 199, 255, 0.35);
    }

    .subtitle {
      margin-top: 8px;
      color: var(--muted);
      font-size: 14px;
    }

    .grid {
      display: grid;
      gap: 18px;
      grid-template-columns: minmax(320px, 540px) minmax(420px, 1fr);
    }

    .card {
      position: relative;
      background: linear-gradient(165deg, rgba(17, 25, 46, 0.96), rgba(10, 14, 31, 0.95));
      border: 1px solid rgba(70, 95, 156, 0.5);
      border-radius: 18px;
      padding: 20px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.32), inset 0 0 0 1px rgba(157, 183, 255, 0.04);
      overflow: hidden;
    }

    .card::after {
      content: "";
      position: absolute;
      inset: -80px auto auto -80px;
      width: 170px;
      height: 170px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(89, 199, 255, 0.2), transparent 75%);
      pointer-events: none;
    }

    h2 {
      margin: 0 0 14px;
      font-size: 20px;
      letter-spacing: 0.35px;
    }

    .field {
      display: grid;
      gap: 7px;
      margin-bottom: 12px;
    }

    .row {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    label {
      font-size: 13px;
      color: #ced8f7;
      letter-spacing: 0.22px;
    }

    input, select {
      width: 100%;
      background: rgba(7, 11, 27, 0.95);
      color: #f4f7ff;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px 13px;
      outline: none;
      transition: border-color .2s ease, box-shadow .2s ease, transform .2s ease;
    }

    input:focus, select:focus {
      border-color: rgba(89, 199, 255, 0.95);
      box-shadow: 0 0 0 3px rgba(89, 199, 255, 0.22);
      transform: translateY(-1px);
    }

    .actions {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      margin-top: 14px;
    }

    button {
      position: relative;
      border: 0;
      border-radius: 12px;
      color: #05111f;
      font-weight: 700;
      letter-spacing: 0.3px;
      padding: 12px 12px;
      cursor: pointer;
      transition: transform .16s ease, box-shadow .2s ease, filter .2s ease, opacity .2s ease;
    }

    .btn-primary {
      background: linear-gradient(120deg, #61ccff, #83ffca);
      box-shadow: var(--glow);
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.34);
    }

    .btn-secondary {
      background: linear-gradient(120deg, #abbeff, #7ca6ff);
      box-shadow: 0 0 24px rgba(142, 166, 255, 0.35);
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px) scale(1.015);
      filter: saturate(1.08);
    }

    button:active:not(:disabled) {
      transform: translateY(1px) scale(0.995);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: .5;
      box-shadow: none;
      filter: grayscale(.2);
    }

    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(5, 17, 31, .35);
      border-top-color: rgba(5, 17, 31, .95);
      margin-right: 6px;
      vertical-align: -2px;
      animation: spin .7s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 7px 11px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid rgba(120, 151, 235, .45);
      background: rgba(89, 199, 255, .12);
      color: #dbf4ff;
      margin-bottom: 10px;
    }

    .status-ok { background: rgba(69, 240, 161, .15); border-color: rgba(69, 240, 161, .45); color: #ddffe7; }
    .status-bad { background: rgba(255, 109, 155, .18); border-color: rgba(255, 109, 155, .45); color: #ffe2ec; }

    .log-panel {
      min-height: 360px;
      max-height: 470px;
      overflow: auto;
      border-radius: 14px;
      padding: 12px;
      border: 1px solid rgba(64, 90, 156, .55);
      background: linear-gradient(180deg, rgba(6, 10, 24, .98), rgba(7, 12, 28, .92));
      font-family: "Cascadia Mono", "Consolas", monospace;
      font-size: 12px;
      line-height: 1.56;
      white-space: pre-wrap;
      color: #d4e1ff;
    }

    .parts {
      margin-top: 10px;
      border-top: 1px solid rgba(87, 114, 182, .45);
      padding-top: 10px;
      max-height: 180px;
      overflow: auto;
      font-size: 13px;
      color: #e5ecff;
    }

    .parts code {
      display: block;
      padding: 4px 0;
      color: #b8ffdd;
    }

    .connected {
      margin-top: 12px;
      font-size: 13px;
      color: #d7e4ff;
    }

    @media (max-width: 1100px) {
      .grid { grid-template-columns: 1fr; }
      .actions { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="title-wrap">
    <h1 class="app-title">TikTok Scheduler Uploader</h1>
    <div class="subtitle">Process anime recap clips, connect TikTok OAuth, and upload draft parts.</div>
  </div>

  <div class="grid">
    <section class="card">
      <h2>Pipeline Inputs</h2>
      <div class="field">
        <label for="urlInput">Source URL</label>
        <input id="urlInput" placeholder="https://www.youtube.com/watch?v=..." />
      </div>
      <div class="field">
        <label for="titleInput">Caption Title</label>
        <input id="titleInput" placeholder="Solo Leveling Recap" />
      </div>
      <div class="field">
        <label for="channelInput">Channel</label>
        <select id="channelInput">
          <option value="anime recaps">anime recaps</option>
        </select>
      </div>

      <div class="row">
        <div class="field">
          <label for="cropInput">Crop Top PX</label>
          <input id="cropInput" type="number" value="0" />
        </div>
        <div class="field">
          <label for="intervalInput">Interval Minutes</label>
          <input id="intervalInput" type="number" value="30" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="partSecInput">Part Seconds</label>
          <input id="partSecInput" type="number" value="70" />
        </div>
        <div class="field">
          <label for="yScaleInput">Y Scale</label>
          <input id="yScaleInput" type="number" step="0.01" value="2.08" />
        </div>
      </div>

      <div class="field">
        <label for="yScaleModeInput">Y Scale Mode</label>
        <select id="yScaleModeInput">
          <option value="fill" selected>fill</option>
          <option value="manual">manual</option>
        </select>
      </div>

      <div class="field">
        <label for="titleMaskInput">Title Mask PX</label>
        <input id="titleMaskInput" type="number" value="0" />
      </div>

      <div class="field">
        <label for="labelPosInput">Part Label Position</label>
        <select id="labelPosInput">
          <option value="top-center">top-center</option>
          <option value="top-left">top-left</option>
        </select>
      </div>

      <div class="field">
        <label><input id="noOverlayInput" type="checkbox" /> Disable Part X overlay</label>
      </div>

      <div class="actions">
        <button id="processBtn" class="btn-primary">Process Video</button>
        <button id="connectBtn" class="btn-secondary">Connect TikTok</button>
        <button id="uploadBtn" class="btn-primary" disabled>Upload Drafts</button>
      </div>

      <div class="connected" id="connectState">TikTok status: checking...</div>
    </section>

    <section class="card">
      <h2>Live Status</h2>
      <div id="statusChip" class="status-chip">Idle</div>
      <div id="logPanel" class="log-panel">Waiting for actions...</div>
      <div id="partsPanel" class="parts"></div>
    </section>
  </div>

  <script>
    const state = {
      jobId: null,
      processing: false,
      uploading: false,
      connected: false,
      pollId: null,
      lastLogs: [],
    };

    const el = {
      url: document.getElementById("urlInput"),
      title: document.getElementById("titleInput"),
      channel: document.getElementById("channelInput"),
      crop: document.getElementById("cropInput"),
      interval: document.getElementById("intervalInput"),
      partSec: document.getElementById("partSecInput"),
      yScale: document.getElementById("yScaleInput"),
      yScaleMode: document.getElementById("yScaleModeInput"),
      titleMask: document.getElementById("titleMaskInput"),
      labelPos: document.getElementById("labelPosInput"),
      noOverlay: document.getElementById("noOverlayInput"),
      processBtn: document.getElementById("processBtn"),
      connectBtn: document.getElementById("connectBtn"),
      uploadBtn: document.getElementById("uploadBtn"),
      statusChip: document.getElementById("statusChip"),
      logPanel: document.getElementById("logPanel"),
      partsPanel: document.getElementById("partsPanel"),
      connectState: document.getElementById("connectState"),
    };

    function setButtonLoading(button, loading, text) {
      if (!button.dataset.baseText) button.dataset.baseText = button.textContent;
      if (loading) {
        button.innerHTML = `<span class="spinner"></span>${text}`;
      } else {
        button.textContent = button.dataset.baseText;
      }
    }

    function appendLog(message) {
      const now = new Date().toLocaleTimeString();
      const line = `[${now}] ${message}`;
      el.logPanel.textContent += (el.logPanel.textContent ? "\n" : "") + line;
      el.logPanel.scrollTop = el.logPanel.scrollHeight;
    }

    function replaceLogs(lines) {
      if (!Array.isArray(lines) || lines.length === 0) return;
      if (JSON.stringify(lines) === JSON.stringify(state.lastLogs)) return;
      state.lastLogs = lines.slice();
      el.logPanel.textContent = lines.join("\n");
      el.logPanel.scrollTop = el.logPanel.scrollHeight;
    }

    function setStatus(label, kind = "default") {
      el.statusChip.textContent = label;
      el.statusChip.classList.remove("status-ok", "status-bad");
      if (kind === "ok") el.statusChip.classList.add("status-ok");
      if (kind === "bad") el.statusChip.classList.add("status-bad");
    }

    function setParts(files) {
      if (!files || files.length === 0) {
        el.partsPanel.innerHTML = "No parts yet.";
        return;
      }
      el.partsPanel.innerHTML = files
        .map((path) => `<code>${path}</code>`)
        .join("");
    }

    function setFormDisabled(disabled) {
      [el.url, el.title, el.channel, el.crop, el.interval, el.partSec, el.yScale, el.yScaleMode, el.titleMask, el.labelPos, el.noOverlay].forEach((item) => {
        item.disabled = disabled;
      });
      el.processBtn.disabled = disabled || state.processing || state.uploading;
      el.uploadBtn.disabled = !state.jobId || !state.connected || state.processing || state.uploading;
    }

    async function fetchJSON(url, options = {}) {
      const res = await fetch(url, options);
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        const detail = data.detail || JSON.stringify(data) || `HTTP ${res.status}`;
        throw new Error(detail);
      }
      return data;
    }

    async function refreshConnectionState() {
      try {
        const me = await fetchJSON("/api/me");
        state.connected = !!me.connected;
        el.connectState.textContent = state.connected
          ? "TikTok status: Connected ✅"
          : "TikTok status: Not connected";
      } catch (error) {
        state.connected = false;
        el.connectState.textContent = `TikTok status: Error (${error.message})`;
      }
      setFormDisabled(state.processing || state.uploading);
    }

    async function loadChannels() {
      try {
        const payload = await fetchJSON("/api/channels");
        const channels = Array.isArray(payload.channels) ? payload.channels : [];
        if (!channels.length) return;
        el.channel.innerHTML = channels
          .map((name) => `<option value="${name.replace(/"/g, "&quot;")}">${name}</option>`)
          .join("");
        if (channels.includes("anime recaps")) {
          el.channel.value = "anime recaps";
        }
      } catch (error) {
        appendLog(`Could not load channel list: ${error.message}`);
      }
    }

    async function pollStatus() {
      if (!state.jobId) return;
      try {
        const status = await fetchJSON(`/api/status/${encodeURIComponent(state.jobId)}`);
        replaceLogs(status.logs || []);
        setParts(status.part_files || (status.status && status.status.part_files) || []);
        if (status.state === "processed") {
          setStatus("Processed ✅", "ok");
          state.processing = false;
        } else if (status.state === "uploaded") {
          setStatus("Uploaded ✅", "ok");
          state.uploading = false;
        } else if (status.state === "failed" || status.state === "upload_failed") {
          setStatus("Failed ❌", "bad");
          state.processing = false;
          state.uploading = false;
          if (status.error) appendLog(`Error: ${status.error}`);
        } else {
          setStatus(status.state || "running");
        }

        if (!state.processing && !state.uploading && state.pollId) {
          clearInterval(state.pollId);
          state.pollId = null;
        }
      } catch (error) {
        appendLog(`Status poll error: ${error.message}`);
      } finally {
        setButtonLoading(el.processBtn, state.processing, "Processing...");
        setButtonLoading(el.uploadBtn, state.uploading, "Uploading...");
        setFormDisabled(state.processing || state.uploading);
      }
    }

    function ensurePolling() {
      if (state.pollId) return;
      state.pollId = setInterval(pollStatus, 1000);
    }

    el.processBtn.addEventListener("click", async () => {
      if (!el.url.value.trim() || !el.title.value.trim() || !el.channel.value.trim()) {
        appendLog("URL, title, and channel are required.");
        return;
      }

      state.processing = true;
      state.uploading = false;
      state.lastLogs = [];
      el.logPanel.textContent = "";
      setButtonLoading(el.processBtn, true, "Processing...");
      setStatus("Processing...");
      setFormDisabled(true);

      try {
        const payload = {
          url: el.url.value.trim(),
          title: el.title.value.trim(),
          channel: el.channel.value.trim(),
          crop_top_px: Number(el.crop.value || 0),
          title_mask_px: Number(el.titleMask.value || 0),
          video_y_scale: Number(el.yScale.value || 2.08),
          y_scale_mode: el.yScaleMode.value || "fill",
          render_preset: "legacy",
          interval_min: Number(el.interval.value || 30),
          part_seconds: Number(el.partSec.value || 70),
          part_label_position: el.labelPos.value,
          no_part_overlay: !!el.noOverlay.checked,
        };
        const data = await fetchJSON("/api/process", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        state.jobId = data.job_id;
        appendLog(`Job started: ${state.jobId}`);
        ensurePolling();
      } catch (error) {
        appendLog(`Process request failed: ${error.message}`);
        setStatus("Failed ❌", "bad");
        state.processing = false;
      } finally {
        setButtonLoading(el.processBtn, state.processing, "Processing...");
        setFormDisabled(state.processing || state.uploading);
      }
    });

    el.connectBtn.addEventListener("click", () => {
      appendLog("Opening TikTok OAuth...");
      window.open("/auth/start", "_blank");
      setTimeout(refreshConnectionState, 1800);
      setTimeout(refreshConnectionState, 5000);
    });

    el.uploadBtn.addEventListener("click", async () => {
      if (!state.jobId) {
        appendLog("No processed job found. Run Process Video first.");
        return;
      }
      if (!state.connected) {
        appendLog("Connect TikTok before uploading.");
        return;
      }

      state.uploading = true;
      setButtonLoading(el.uploadBtn, true, "Uploading...");
      setStatus("Uploading drafts...");
      setFormDisabled(true);

      try {
        const payload = {
          job_id: state.jobId,
          title: el.title.value.trim(),
          channel: el.channel.value.trim(),
          interval_min: Number(el.interval.value || 30),
        };
        await fetchJSON("/api/upload", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        appendLog("Upload queue started.");
        ensurePolling();
      } catch (error) {
        appendLog(`Upload request failed: ${error.message}`);
        setStatus("Upload failed ❌", "bad");
        state.uploading = false;
      } finally {
        setButtonLoading(el.uploadBtn, state.uploading, "Uploading...");
        setFormDisabled(state.processing || state.uploading);
      }
    });

    loadChannels();
    refreshConnectionState();
    setParts([]);
  </script>
</body>
</html>
